---
## Front matter
title: "Отчёт по лабораторной работе №6"
subtitle: "Управление процессами"
author: "Щемелев Илья Владимирович"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true
toc-depth: 2
lof: true
lot: true
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
    - spelling=modern
    - babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float}
  - \floatplacement{figure}{H}
---

# Цель работы

Получить навыки управления процессами операционной системы.

# Ход выполнения

## Управление заданиями и процессами в Linux

1. Для выполнения административных операций получены полномочия суперпользователя с использованием команды `su`. После успешной аутентификации работа продолжена в корневой оболочке.

2. В терминале последовательно запущены три процесса.  
   Первый процесс `sleep 3600` был запущен в фоновом режиме. Далее в фоне запущен процесс `dddd if=/dev/zero of=/dev/null`, создающий высокую нагрузку на процессор.  
   Последняя команда `sleep 7200` была запущена без использования символа фонового выполнения, в результате чего управление оболочкой было заблокировано.

3. Для возврата управления оболочкой использовано сочетание клавиш **Ctrl + Z**, после чего выполнение процесса `sleep 7200` было приостановлено и переведено в состояние **Stopped**.

4. С помощью команды `jobs` выведен список активных заданий.  
   В результате отображены три задания: два в состоянии **Running** и одно в состоянии **Stopped**, что подтверждает корректную работу механизма управления заданиями оболочки.

   ![Просмотр списка заданий](Screenshot_1.png)

5. Для продолжения выполнения третьего задания в фоновом режиме использована команда `bg 3`.  
   Повторный просмотр списка заданий показал, что задание перешло в состояние **Running**.

6. Для переноса первого задания на передний план выполнена команда `fg 1`, в результате чего процесс `sleep 3600` стал активным в текущем терминале.

7. Выполнение задания 1 было завершено с помощью сочетания клавиш **Ctrl + C**.  
   Повторная проверка списка заданий показала отсутствие данного процесса.

8. Аналогичным образом были завершены задания 2 и 3, после чего активные задания в текущей сессии отсутствовали.

9. Во втором терминале под учётной записью обычного пользователя был запущен процесс `dd if=/dev/zero of=/dev/null` в фоновом режиме. После этого терминал был закрыт командой выхода из оболочки.

10. В основном терминале под той же учётной записью запущена утилита мониторинга процессов `top`.  
    Несмотря на закрытие второго терминала, процесс `dd` продолжал выполняться, что подтверждает его независимость от интерактивной сессии оболочки.

    ![Отображение процесса dd в top](Screenshot_2.png)

11. После повторного запуска `top` с помощью встроенной команды завершения процесса был принудительно остановлен процесс `dd`. После этого выполнен выход из утилиты мониторинга.

    ![Завершение процесса dd через top](Screenshot_3.png)

## Управление процессами

1. Повторно получены полномочия администратора.

2. В терминале запущены три процесса `dd if=/dev/zero of=/dev/null` в фоновом режиме, создающие высокую нагрузку на вычислительные ресурсы системы.

3. С помощью просмотра списка процессов, содержащих имя `dd`, были определены идентификаторы всех запущенных процессов данного типа.

4. Используя идентификатор одного из процессов `dd`, выполнено изменение его приоритета. В результате приоритет выбранного процесса был понижен, что подтверждено сообщением системы.

   ![Изменение приоритета процесса](Screenshot_4.png)

5. Для анализа иерархии процессов выполнен вывод древовидного списка процессов с отображением родительских и дочерних связей. Это позволило определить оболочку, из которой были запущены все процессы `dd`.

6. После определения идентификатора родительской оболочки выполнено её принудительное завершение. В результате вместе с родительским процессом были автоматически завершены все дочерние процессы `dd`.

   ![Завершение родительского процесса и всех дочерних процессов](Screenshot_5.png)

## Самостоятельная работа

### Задание 1. Управление приоритетами процессов

1. В корневой оболочке трижды был запущен процесс, создающий высокую нагрузку на процессор и подсистему ввода-вывода, в фоновом режиме.  
   В результате в системе одновременно выполнялись три процесса одного типа.

   ![Запуск процессов dd в фоновом режиме](Screenshot_6.png)

2. Для одного из запущенных процессов был изменён приоритет выполнения.  
   Сначала значение приоритета было увеличено до −5, что привело к повышению относительного приоритета процесса по сравнению с остальными пользовательскими процессами.

3. Затем приоритет того же процесса был изменён повторно, на значение −15.  
   Разница между значениями −5 и −15 заключается в степени приоритетности: при значении −15 процесс получает значительно больше процессорного времени, вытесняя другие процессы с более низким приоритетом. Чем меньше числовое значение приоритета, тем выше фактический приоритет выполнения.

4. После завершения эксперимента все запущенные процессы данного типа были корректно остановлены одновременно, что подтвердило возможность массового завершения однотипных процессов.

### Задание 2. Управление заданиями и сигналами

1. Программа `yes` была запущена в фоновом режиме с перенаправлением вывода в специальное устройство, что позволило исключить вывод данных в терминал.

   ![Фоновый запуск yes с подавлением вывода](Screenshot_7.png)

2. Далее программа `yes` была запущена на переднем плане с подавлением вывода.  
   Выполнение программы было приостановлено, после чего она была повторно запущена с теми же параметрами и завершена принудительно.

3. Затем программа `yes` была запущена на переднем плане без подавления вывода.  
   Активный вывод в терминал подтвердил корректность работы программы. Процесс был приостановлен, повторно запущен и завершён.

   ![Запуск yes без подавления вывода](Screenshot_8.png)

4. С помощью просмотра списка заданий определено текущее состояние процессов.  
   Было подтверждено наличие фонового задания в состоянии **Running**.

5. Процесс, выполнявшийся в фоновом режиме, был переведён на передний план, после чего его выполнение было остановлено.

6. Один из процессов с подавлением потока вывода был переведён в фоновый режим, после чего повторно проверено состояние заданий.

7. Просмотр состояний заданий показал, что процесс успешно выполняется в фоновом режиме и имеет статус **Running**.

   ![Состояние заданий после перевода в фон](Screenshot_9.png)

8. Один из процессов был запущен в фоновом режиме таким образом, чтобы продолжать выполнение даже после завершения терминальной сессии.

9. После закрытия окна терминала и повторного запуска консоли было подтверждено, что процесс продолжил своё выполнение, что свидетельствует о его независимости от пользовательской сессии.

10. С помощью утилиты мониторинга процессов был получен обзор текущего состояния системы, включая активные процессы, загрузку процессора и использование памяти.

    ![Мониторинг процессов с помощью top](Screenshot_10.png)

11. Дополнительно были запущены ещё три процесса `yes` в фоновом режиме с подавлением вывода.

12. Два процесса были завершены различными способами: один — по идентификатору процесса, другой — по идентификатору задания, что продемонстрировало разные подходы к управлению процессами.

13. Выполнена попытка отправки сигнала SIGHUP процессу, запущенному с сохранением работы после выхода из терминала, и обычному процессу.  
    В результате обычный процесс завершился, тогда как защищённый процесс продолжил выполнение.

14. После этого было запущено ещё несколько процессов `yes` в фоновом режиме с подавлением вывода.

15. Все запущенные процессы данного типа были завершены одновременно, что подтвердило возможность группового управления процессами.

   ![Завершение процессов yes](Screenshot_11.png)

16. Программа `yes` была запущена в фоновом режиме, после чего аналогичный процесс был запущен с повышенным относительным приоритетом.  
    Сравнение абсолютных и относительных приоритетов показало различие в распределении процессорного времени между процессами.

17. С помощью изменения приоритета одного из процессов подтверждена возможность динамического управления приоритетами уже запущенных процессов.

# Контрольные вопросы

1. **Какая команда даёт обзор всех текущих заданий оболочки?**  
   Для просмотра всех заданий, запущенных в текущей оболочке, используется команда **jobs**.  
   Она отображает список заданий, их номера и текущее состояние (Running, Stopped и т.д.).

2. **Как остановить текущее задание оболочки, чтобы продолжить его выполнение в фоновом режиме?**  
   Для этого необходимо:
   - приостановить выполнение текущего задания с помощью сочетания клавиш **Ctrl + Z**;
   - затем возобновить его выполнение в фоновом режиме с помощью команды **bg**.

3. **Какую комбинацию клавиш можно использовать для отмены текущего задания оболочки?**  
   Для немедленного завершения текущего задания используется сочетание клавиш **Ctrl + C**, которое отправляет процессу сигнал прерывания.

4. **Необходимо отменить одно из начатых заданий. Доступ к оболочке, в которой в данный момент работает пользователь, невозможен. Что можно сделать, чтобы отменить задание?**  
   В этом случае можно:
   - определить идентификатор процесса (PID) с помощью утилит просмотра процессов;
   - завершить процесс из другой оболочки, отправив ему сигнал завершения.  
   Таким образом, задание будет остановлено независимо от доступа к исходной оболочке.

5. **Какая команда используется для отображения отношений между родительскими и дочерними процессами?**  
   Для отображения иерархии процессов применяется команда **ps** с параметрами, позволяющими вывести древовидную структуру процессов, где видны связи между родительскими и дочерними процессами.

6. **Какая команда позволит изменить приоритет процесса с идентификатором 1234 на более высокий?**  
   Для изменения приоритета уже запущенного процесса используется команда **renice**.  
   Уменьшение числового значения приоритета приводит к его повышению.

7. **В системе в настоящее время запущено 20 процессов dd. Как проще всего остановить их все сразу?**  
   Наиболее простой способ — использовать команду **killall**, указав имя процесса.  
   Это позволит завершить все процессы с заданным именем одной командой.

8. **Какая команда позволяет остановить команду с именем mycommand?**  
   Для завершения процесса по его имени используется команда **killall mycommand**, которая отправляет сигнал завершения всем процессам с данным именем.

9. **Какая команда используется в top, чтобы убить процесс?**  
   В интерактивном режиме утилиты **top** для завершения процесса используется команда **k**, после чего указывается идентификатор процесса и сигнал.

10. **Как запустить команду с достаточно высоким приоритетом, не рискуя, что не хватит ресурсов для других процессов?**  
    Для этого используется команда **nice**, позволяющая задать повышенный приоритет при запуске процесса, но в допустимых пределах.  
    Такой подход обеспечивает более эффективное выполнение процесса без критического вытеснения других задач системы.

# Заключение

В ходе выполнения лабораторной работы были изучены и закреплены основные принципы управления заданиями и процессами в операционной системе Linux. Освоены приёмы запуска процессов в фоновом и переднем режиме, их приостановки и завершения, изменения приоритетов выполнения, а также работы с сигналами и мониторинга состояния системы. Полученные навыки позволяют эффективно контролировать выполнение программ и рационально распределять вычислительные ресурсы системы.
