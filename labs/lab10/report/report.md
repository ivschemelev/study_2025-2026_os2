---
## Front matter
title: "Отчёт по лабораторной работе №10"
subtitle: "Основы работы с модулями ядра операционной системы"
author: "Щемелев Илья Владимирович"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true
toc-depth: 2
lof: true
lot: true
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
    - spelling=modern
    - babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float}
  - \floatplacement{figure}{H}
---

# Цель работы

Получить навыки работы с утилитами управления модулями ядра операционной системы.

# Ход выполнения

## Управление модулями ядра из командной строки

1. В системе запущен терминал и получены полномочия администратора (пользователь **root**) командой `su -`.  
   Это необходимо, поскольку просмотр информации о драйверах/модулях и операции `modprobe` (загрузка/выгрузка модулей) требуют прав суперпользователя.

2. Для определения доступных устройств и связанных с ними модулей ядра выполнена команда `lspci -k`.  
   В выводе отображаются PCI-устройства, а также строки **Kernel driver in use** и **Kernel modules**, позволяющие установить, какой модуль обслуживает конкретное устройство и какие модули доступны для него.

   По результатам команды были выявлены основные устройства виртуальной машины и соответствующие им модули:

   - **IDE interface (Intel PIIX4 IDE)** — используется драйвер **ata_piix**, дополнительно доступен **ata_generic**.  
     Это типичная подсистема хранения для виртуализированных конфигураций с PIIX-чипсетом.
   - **VGA compatible controller (VMware SVGA II Adapter)** — используется драйвер **vmwgfx**.  
     Такой адаптер часто встречается в виртуальных средах; модуль обеспечивает работу графической подсистемы.
   - **Ethernet controller (Intel 82540EM Gigabit Ethernet Controller)** — используется драйвер **e1000**.  
     Данный сетевой адаптер является распространённым «виртуальным» устройством, поддерживаемым модулем e1000.
   - **VirtualBox Guest Service (InnoTek Systemberatung GmbH)** — используется модуль **vboxguest**.  
     Он относится к гостевым дополнениям VirtualBox и обеспечивает интеграцию гостевой ОС с хостом.
   - **Multimedia audio controller (Intel AC'97)** — используется драйвер **snd_intel8x0** (а также связанные аудиомодули ALSA).
   - **SATA controller (Intel ICH8M/ICH9M-E SATA AHCI)** — используется драйвер **ahci**, обеспечивающий работу SATA-контроллера в режиме AHCI.

   ![Просмотр устройств и связанных модулей (lspci -k)](Screenshot_1.png)

3. Для просмотра списка загруженных модулей ядра выполнена команда `lsmod | sort`.  
   Вывод содержит таблицу с ключевыми полями:
   - **Module** — имя модуля;
   - **Size** — размер модуля в байтах;
   - **Used by** — количество и список модулей/подсистем, которые используют данный модуль.

   В списке присутствуют, в том числе, модули хранения (**ahci**, **ata_piix**, **libata**), виртуализации/графики (**vmwgfx**), сети (**e1000**), а также системные компоненты (например, подсистема device-mapper — **dm_mod**, поддержка FUSE — **fuse**).

   ![Список загруженных модулей (lsmod | sort)](Screenshot_2.png)

## Работа с модулем файловой системы ext4

4. Проверено, загружен ли модуль **ext4**, командой `lsmod | grep ext4`.  
   На данном этапе совпадений не обнаружено, что означает отсутствие загруженного модуля **ext4** в памяти ядра на момент проверки.

5. Выполнена загрузка модуля **ext4** командой `modprobe ext4`.  
   Затем повторно выполнена проверка `lsmod | grep ext4`.  
   После загрузки в выводе появился модуль **ext4**, а также связанные зависимости **jbd2** и **mbcache**, которые используются файловой системой ext4 для журналирования и кэширования метаданных.

   ![Загрузка ext4 и проверка наличия в lsmod](Screenshot_3.png)

6. Получена подробная информация о модуле ext4 командой `modinfo ext4`.

   По результатам вывода можно сделать следующие пояснения по основным полям:
   - **filename** — путь к файлу модуля в системе (расположение `.ko.xz` внутри каталога `/lib/modules/<версия_ядра>/...`);
   - **license** — лицензия модуля (в данном случае **GPL**);
   - **description** — назначение (файловая система Fourth Extended Filesystem);
   - **author** — авторы/разработчики;
   - **alias** — альтернативные идентификаторы, по которым модуль может автоматически подбираться системой (в т.ч. совместимость с **ext2/ext3**);
   - **depends** — зависимости (например, **jbd2**, **mbcache**);
   - **intree: Y** — модуль входит в состав основного дерева исходников ядра;
   - **vermagic** — строка совместимости с конкретной версией/конфигурацией ядра (важно для корректной загрузки);
   - **signer / sig_key** — сведения о подписи модуля (используется при проверке целостности/подлинности).

   Также следует отметить, что у модуля **ext4** отсутствуют настраиваемые параметры загрузки: в выводе нет строк вида `parm:` — это означает, что модуль не предоставляет пользовательских параметров через `modprobe`.

7. Выполнена попытка выгрузки модуля **ext4** командой `modprobe -r ext4`.  
   Команда была введена несколько раз. Сообщений об ошибках система не вывела, что означает успешную выгрузку модуля при условии отсутствия активных точек монтирования ext4/зависимостей, препятствующих выгрузке.

8. Выполнена попытка выгрузки модуля **xfs** командой `modprobe -r xfs`.  
   Система вернула ошибку **`modprobe: FATAL: Module xfs is in use.`**  
   Это означает, что модуль **xfs** задействован в текущей работе системы (как правило, файловая система XFS используется для одного из смонтированных разделов, часто — для корневого или системных томов), поэтому ядро запрещает его выгрузку во избежание повреждения данных и нарушения работы ОС.

   ![Попытка выгрузки ext4 и ошибка при выгрузке xfs](Screenshot_4.png)

## Загрузка модулей ядра с параметрами (на примере bluetooth)

9. Проверено, загружен ли модуль **bluetooth**, командой `lsmod | grep bluetooth`.  
   До загрузки совпадений не обнаружено, следовательно, модуль Bluetooth не был активен.

10. Выполнена загрузка модуля Bluetooth командой `modprobe bluetooth`.  
    После чего повторно просмотрены связанные модули командой `lsmod | grep bluetooth`.  
    В выводе появился модуль **bluetooth**, а также модуль **rfkill**, который используется для программной блокировки/разблокировки радиоинтерфейсов (Bluetooth/Wi-Fi и др.) и является зависимостью Bluetooth-подсистемы.

    ![Загрузка bluetooth и просмотр связанных модулей](Screenshot_5.png)

11. Получена информация о модуле Bluetooth командой `modinfo bluetooth`.  
    Помимо стандартных полей (путь к модулю, описание, зависимости, vermagic, сведения о подписи), в конце вывода присутствуют строки **`parm:`**, то есть параметры, которые могут задаваться при загрузке модуля.

    Для данного модуля доступны следующие параметры (все типа **bool**):
    - **disable_esco** — отключение создания eSCO-соединений (режим Bluetooth-аудио);
    - **disable_ertm** — отключение Enhanced Retransmission Mode (ERTM) для L2CAP;
    - **enable_ecred** — включение Enhanced Credit Based Flow Control Mode.

    Наличие этих параметров позволяет изменять поведение Bluetooth-подсистемы при загрузке модуля, например: `modprobe bluetooth disable_ertm=1` (пример принципа задания параметра).

12. Выполнена выгрузка модуля Bluetooth командой `modprobe -r bluetooth`.  
    Выгрузка прошла без ошибок, что указывает на отсутствие активных Bluetooth-подключений/зависимостей, удерживающих модуль в памяти.

    ![Параметры bluetooth и выгрузка модуля](Screenshot_6.png)

## Обновление ядра системы

13. Проверена текущая версия ядра командой `uname -r`.  
    Установлено, что система использует ядро версии **6.12.0-124.21.1.el10_1.x86_64**.

14. Просмотрен список пакетов, относящихся к ядру, командой `dnf list kernel`.  
    В системе присутствуют пакеты ядра, включая установленное ядро текущей версии, а также пакет предыдущей версии, оставленный в системе для возможности отката (типичное поведение при обновлениях ядра).

15. Выполнены команды обновления `dnf update kernel`, затем `dnf update` и `dnf upgrade --refresh`.  
    По выводу видно, что зависимости разрешены успешно, однако обновления не требуются — система сообщает **Nothing to do**.  
    Это означает, что на момент проверки установлены актуальные пакеты (включая ядро), доступные в подключённых репозиториях.

    ![Проверка версии ядра и попытка обновления через dnf](Screenshot_7.png)

16. Выполнена перезагрузка системы (перезапуск виртуальной машины). После загрузки повторно проверены версия ядра и сведения о системе командами `uname -r` и `hostnamectl`.  

    Версия ядра после перезагрузки подтверждена как **6.12.0-124.21.1.el10_1.x86_64**.

    Команда `hostnamectl` дополнительно показала параметры окружения:
    - **Operating System:** Rocky Linux **10.1 (Red Quartz)**;
    - **Virtualization:** **oracle** (VirtualBox);
    - сведения о хостнейме (**ivschemelev.localdomain**) и аппаратной модели (**VirtualBox**).

    Это подтверждает, что система работает в среде виртуализации VirtualBox и использует актуальное ядро, установленное в ОС.

    ![Проверка версии ядра и сведений о системе (hostnamectl)](Screenshot_8.png)

# Контрольные вопросы

1. Текущую версию ядра, которая используется на системе, показывает команда:

   * **uname -r** — выводит строку версии загруженного ядра (release).
     Данная команда удобна для быстрой проверки, какое именно ядро в данный момент активно.

2. Более подробную информацию о текущей версии ядра операционной системы можно получить следующими способами:

   * **uname -a** — выводит расширенные сведения: имя ядра, имя хоста, версию, дату сборки и архитектуру.
     Это наиболее полный вариант вывода среди команд `uname`.
   * **hostnamectl** — отображает сведения о системе, включая строку **Kernel**, а также информацию об ОС, архитектуре и среде виртуализации (если используется).
     Данный вариант удобен, когда нужно получить общую «паспортную» информацию о системе.

3. Список загруженных модулей ядра показывает команда:

   * **lsmod** — выводит перечень модулей, их размер и количество/список зависимостей (кто использует модуль).
     Часто применяется совместно с фильтрацией, например `lsmod | grep имя_модуля`.

4. Команда, позволяющая определять параметры модуля ядра:

   * **modinfo имя_модуля** — отображает сведения о модуле, включая поддерживаемые параметры (строки вида **parm:**).
     Если параметров нет, значит модуль не предоставляет настраиваемых опций через `modprobe`.

5. Для выгрузки модуля ядра используется команда:

   * **modprobe -r имя_модуля** — корректно выгружает модуль и при необходимости пытается выгрузить связанные зависимости.
     Дополнительно также существует:
   * **rmmod имя_модуля** — выгружает модуль напрямую, но обычно предпочтительнее применять `modprobe -r`, так как он учитывает зависимости.

6. Если при попытке выгрузить модуль ядра получено сообщение об ошибке, можно выполнить следующие действия:

   * убедиться, что модуль действительно можно выгружать (часто он используется системой прямо сейчас);
   * определить, какие процессы/подсистемы удерживают модуль (например, устройство активно или файловая система смонтирована);
   * остановить службы или завершить процессы, связанные с использованием устройства/подсистемы (например, отключить сервис, закрыть соединения);
   * размонтировать файловую систему, если модуль относится к используемой ФС (в этом случае выгрузка станет возможной);
   * если модуль критически важен для работы ОС (например, драйвер корневой файловой системы), выгружать его нельзя — в таких ситуациях допускается только перезагрузка в другую конфигурацию либо изменение состава модулей через настройки загрузки/сборку initramfs.

7. Определить, какие параметры модуля ядра поддерживаются, можно так:

   * **modinfo имя_модуля** — параметры перечисляются в строках **parm:** (имя параметра и его назначение).
     Например, для некоторых модулей можно увидеть параметры типа `parm: option=... (bool/int/string)`.

8. Установить новую версию ядра можно следующими действиями:

   * обновить информацию о пакетах и выполнить обновление ядра пакетным менеджером:

     * **dnf update kernel**
   * при необходимости обновить систему целиком, чтобы исключить конфликты зависимостей:

     * **dnf upgrade --refresh**
   * перезагрузить систему и выбрать новое ядро в меню загрузчика (если доступен выбор);
   * после загрузки проверить, что используется новое ядро:

     * **uname -r**
     * при необходимости дополнительно проверить через **hostnamectl** (строка Kernel).


# Заключение

В ходе выполнения лабораторной работы были изучены основные приёмы управления модулями ядра операционной системы Rocky Linux. Были рассмотрены способы получения информации об аппаратных устройствах и связанных с ними модулях, а также выполнены операции загрузки и выгрузки модулей ядра. Отдельное внимание уделено анализу информации о модулях и их параметрах на примере файловой системы ext4 и подсистемы Bluetooth. Кроме того, была выполнена проверка версии ядра и изучен процесс обновления ядра операционной системы. Полученные результаты позволяют лучше понять принципы модульной архитектуры ядра Linux и практику администрирования системы.
